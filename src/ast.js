import uuid from 'node-uuid';

function comparePos(a, b) {
  return a.line - b.line || a.ch - b.ch;
}


// This is the root of the *Abstract Syntax Tree*.  Parser implementations are
// required to spit out an `AST` instance.
export class AST {
  constructor(rootNodes) {

    // the `nodeMap` attribute can be used to look up nodes by their id.

    this.nodeMap = new Map();

    // the `rootNodes` attribute simply contains a list of the top level nodes
    // that were parsed.
    this.rootNodes = rootNodes;
    // the `reverseRootNodes` attribute is a shallow, reversed copy of the rootNodes
    this.reverseRootNodes = rootNodes.slice().reverse();

    this.nextNodeMap = new WeakMap();
    this.prevNodeMap = new WeakMap();

    let lastNode = null;
    for (let rootNode of this.rootNodes) {
      for (let node of rootNode) {
        if (node) {
          if (lastNode) {
            this.nextNodeMap.set(lastNode, node);
            this.prevNodeMap.set(node, lastNode);
          }
          this.nodeMap.set(node.id, node);
          lastNode = node;
        }
      }
    }
  }
 
  getNodeAfter(selection) {
    return this.nextNodeMap.get(selection)
        || this.rootNodes.find(node => comparePos(node.from, selection) >= 0)
        || this.rootNodes[0];
  }

  getNodeBefore(selection) {
    return this.prevNodeMap.get(selection)
        || this.reverseRootNodes.find(node => comparePos(node.to, selection) <= 0)
        || this.reverseRootNodes[0];
  }
}

// Every node in the AST inherits from the `ASTNode` class, which is used to
// house some common attributes.
class ASTNode {
  constructor(from, to, type, options) {

    // The `from` and `to` attributes are objects containing th eclstart and end
    // positions of this node within the source document. They are in the format
    // of `{line: <line>, ch: <column>}`.
    this.from = from;
    this.to = to;

    // Every node has a `type` attribute, which is simply a human readable
    // string sepcifying what type of node it is. This helps with debugging and
    // with writing renderers.
    this.type = type;

    // Every node also has an `options` attribute, which is just an open ended
    // object that you can put whatever you want in it. This is useful if you'd
    // like to persist information from your parser about a particular node, all
    // the way through to the renderer. For example, when parsing wescheme code,
    // human readable aria labels are generated by the parser, stored in the
    // options object, and then rendered in the renderers.
    this.options = options;

    // Every node also has a globally unique `id` which can be used to look up
    // it's corresponding DOM element, or to look it up in `AST.nodeMap`
    this.id = uuid.v4();
  }
}

export class Unknown extends ASTNode {
  constructor(from, to, elts, options={}) {
    super(from, to, 'unknown', options);
    this.elts = elts;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let elt of this.elts) {
      for (let node of elt) {
        yield node;
      }
    }
  }

  toString() {
    return `(${this.func} ${this.args.join(' ')})`;
  }
}

export class Expression extends ASTNode {
  constructor(from, to, func, args, options={}) {
    super(from, to, 'expression', options);
    this.func = func;
    this.args = args;
  }

  *[Symbol.iterator]() {
    yield this;
    if (this.func instanceof ASTNode) {
      yield* this.func;
    }
    for (let arg of this.args) {
      for (let node of arg) {
        yield node;
      }
    }
  }

  toString() {
    return `(${this.func} ${this.args.join(' ')})`;
  }
}

export class Struct extends ASTNode {
  constructor(from, to, name, fields, options={}) {
    super(from, to, 'struct', options);
    this.name = name;
    this.fields = fields;
  }

  *[Symbol.iterator]() {
    yield this;
    yield this.name;
    for (let node of this.fields) {
      yield node;
    }
  }

  toString() {
    return `(define-struct ${this.name} ${this.fields.join(' ')})`;
  }
}

export class VariableDefinition extends ASTNode {
  constructor(from, to, name, body, options={}) {
    super(from, to, 'variableDef', options);
    this.name = name;
    this.body = body;
  }

  *[Symbol.iterator]() {
    yield this;
    yield this.name;
    yield this.body;
  }

  toString() {
    return `(define (${this.name} ${this.body})`;
  }
}

export class FunctionDefinition extends ASTNode {
  constructor(from, to, name, args, body, options={}) {
    super(from, to, 'functionDef', options);
    this.name = name;
    this.args = args;
    this.body = body;
  }

  *[Symbol.iterator]() {
    yield this;
    yield this.name;
    for (let node of this.args) {
      yield node;
    }
    yield this.body;
  }
}

//TODO: make this work
export class Conditional extends ASTNode {
  constructor(from, to, condStatement, thenStatement, elseStatement, options={}) {
    super(from, to, 'conditional', options);
    this.condStatement = condStatement;
    this.thenStatement = thenStatement;
    this.elseStatement = elseStatement;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let node of this.condStatement) {
      yield node;
    }
    for (let node of this.thenStatement) {
      yield node;
    }
    if (this.elseStatement) {
      for (let node of this.elseStatement) {
        yield node;
      }
    }
  }

  toString() {
    if (!this.elseStatement) {
      return `if (${this.condStatement}) { ${this.thenStatement.join(' ')} }`;
    }
    return `if (${this.condStatement}) { ${this.thenStatement.join(' ')} } else { ${this.body} })`;
  }
}

//TODO: add a toString() method
export class Assignment extends ASTNode {
  constructor(from, to, operator, left, right, options={}) {
    super(from, to, 'assignment', options);
    this.operator = operator;
    this.left = left;
    this.right = right;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let node of this.left) {
      yield node;
    }
    for (let node of this.right) {
      yield node;
    }
  }
}

//TODO: add a toString() method
//is it possible to merge this somehow with assign class? Almost identical with it
export class Binary extends ASTNode {
  constructor(from, to, operator, left, right, options={}) {
    super(from, to, 'binary', options);
    this.operator = operator;
    this.left = left;
    this.right = right;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let node of this.left) {
      yield node;
    }
    for (let node of this.right) {
      yield node;
    }
  }
}

//TODO: add a toString() method
//use struct toString method as template for this toString() method?
export class Prog extends ASTNode {
  constructor(from, to, prog, options={}) {
    super(from, to, 'prog', options);
    this.prog = prog;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let node of this.prog) {
      yield node;
    }
  }
}

//TODO: add a toString() method
export class Let extends ASTNode {
  constructor(from, to, vars, body, options={}) {
    super(from, to, 'let', options);
    this.vars = vars;
    this.body = body;
  }

  *[Symbol.iterator]() {
    yield this;
    for (let node of this.vars) {
      yield node;
    }
    //why does body not need a for loop to be iterated over
    yield this.body;
  }
}

export class Literal extends ASTNode {
  constructor(from, to, value, dataType='unknown', options={}) {
    super(from, to, 'literal', options);
    this.value = value;
    this.dataType = dataType;
  }

  *[Symbol.iterator]() {
    yield this;
  }

  toString() {
    return `${this.value}`;
  }
}

export class Comment extends ASTNode {
  constructor(from, to, comment, options={}) {
    super(from, to, 'comment', options);
    this.comment = comment;
  }

  *[Symbol.iterator]() {
    yield this;
  }

  toString() {
    return `${this.comment}`;
  }
}

export class Blank extends ASTNode {
  constructor(from, to, value, dataType='blank', options={}) {
    super(from, to, 'blank', options);
    this.value = value;
    this.dataType = dataType;
  }

  *[Symbol.iterator]() {
    yield this;
  }

  toString() {
    return `${this.value}`;
  }
}